import Path from "../item/mark/Path";
import {ItemType, Alignment, LayoutType} from "../util/Constants";
import Mark from "../item/mark/Mark";
import GridLayout from "../layout/Grid";
import PackingLayout from "../layout/Packing";
import TreemapLayout from "../layout/Treemap";
import StackLayout from "../layout/Stack";
import TidyTreeLayout from "../layout/TidyTree";
import ForceLayout from "../layout/Force";
import SugiyamaLayout from "../layout/Sugiyama";
import StrataLayout from "../layout/Strata";

export function evaluatePredicate(itm, p) {
	if ("field" in p) {
		if (!itm.dataScope) return false;
		let f = p["field"];
		if ("value" in p) {
			return itm.dataScope.getFieldValue(f) === p["value"];
		} else if ("interval" in p) {
			let v = itm.dataScope.getFieldValue(f);
			return v >= p["interval"][0] && v <= p["interval"][1];
		} else if ("values" in p) {
			return p["values"].indexOf(itm.dataScope.getFieldValue(f)) >= 0;
		} else {
			return itm.dataScope.hasField(f);
		}
	} else if ("channel" in p) {
		let c = p["channel"];
		if ("value" in p) {
			return itm[c] === p["value"];
		} else if ("interval" in p) {
			return itm[c] >= p["interval"][0] && itm[c] <= p["interval"][1];
		} else if ("values" in p) {
			return p["values"].indexOf(itm[c]) >= 0;
		}
	} else if ("type" in p) {
		return itm.type === p["type"];
	} else if ("id" in p) {
		return itm.id === p["id"];
	} else if ("classId" in p) {
		return itm.classId === p["classId"];
	} else if ("fields" in p) {
		if (!itm.dataScope) return false;
		let f1 = p["fields"][0], f2 = p["fields"][1],
			v1 = itm.dataScope.getFieldValue(f1), v2 = itm.dataScope.getFieldValue(f2);
		switch (p["operator"]) {
			case "==":
				return v1 == v2;
			case ">":
				return v1 > v2;
			case ">=":
				return v1 >= v2;
			case "<":
				return v1 < v2;
			case "<=":
				return v1 <= v2;
		}
	}
	return false;
}

export function findItems(container, predicates) {
	let result = [];
	_findItemsRecursive(container, predicates, result);
	return result;
}

export function _findItemsRecursive(itm, predicates, result) {
	if (!itm) return;
	if (itm.type == "axis" || itm.type == "legend" || itm.type == "gridlines")	return;
	if (_matchCriteria(itm, predicates)) {
		result.push(itm);
	}
	
	if (itm.vertices){
		for (let i of itm.vertices.concat(itm.segments)) {
			if (_matchCriteria(i, predicates))
				result.push(i);
		}
	} else if (itm.children && itm.children.length > 0) {
		for (let c of itm.children)
			_findItemsRecursive(c, predicates, result);
	}
}

function _matchCriteria(cpnt, predicates) {
	for (let p of predicates) {
		if (!evaluatePredicate(cpnt, p))
			return false;
	}
	return true;
}

export function getPeers(item, scene) {
	if (item.type == "vertex") {
		return _getPeerVertices(item, scene);
	} else if (item.type == "segment") {
		return _getPeerSegments(item, scene);
	} else {
		// return item.classId ? findItems(scene, d => d.classId == item.classId) : [];
		return item.classId ? findItems(scene, [{"classId": item.classId}]) : [];
	}
}

//returns an array of peer arrays, peers within each array have the same parent
export function getPeersGroupedByParent(item, scene) {
	let result = {}, peers = getPeers(item, scene);
	for (let p of peers) {
		let parent = p.parent.id;
		if (!(parent in result))
			result[parent] = [];
		result[parent].push(p);
	}
	return Object.keys(result).map(d => result[d]);
}

function _getPeerSegments(segment, container) {
	if (segment.dataScope) {
		let parent = segment.parent;
		if (!parent)	throw new Error("segment has no parent mark");
		let parentPeers = findItems(container, [{"classId": parent.classId}]);
		let results = [];
		for (let p of parentPeers) {
			results = results.concat(p.segments);
		}
		return results;
	} else {
		let parent = segment.parent;
		if (!parent)	throw new Error("segment has no parent mark");
		let index = parent.segments.indexOf(segment);
		let parentPeers = findItems(container, [{"classId": parent.classId}]);
		let results = [];
		for (let p of parentPeers) {
			results.push(p.segments[index]);
		}
		return results;
	}
}

function _getPeerVertices(vertex, container) {
	if (vertex.classId) { //for node-link diagrams
		
	} else if (vertex.dataScope) {
		let parent = vertex.parent;
		if (!parent)	throw new Error("vertex has no parent mark");
		let parentPeers = findItems(container, [{"classId": parent.classId}]);
		let results = [];
		if (parent.type === ItemType.Area) {
			let idx = parent.vertices.indexOf(vertex), firstHalf = idx < parent.vertices.length/2;
			for (let p of parentPeers) {
				let vertices = firstHalf ? p.vertices.slice(0, p.vertices.length/2) : p.vertices.slice(p.vertices.length/2);
				results = results.concat(vertices.filter(d => d.dataScope));
			}
		} else {
			for (let p of parentPeers) {
				results = results.concat(p.vertices.filter(d => d.dataScope));
			}
		}
		return results;
	} else {
		let parent = vertex.parent;
		if (!parent)	throw new Error("vertex has no parent mark");
		let index = parent.vertices.indexOf(vertex);
		let parentPeers = findItems(container, [{"classId": parent.classId}]);
		let results = [];
		for (let p of parentPeers) {
			results.push(p.vertices[index]);
		}
		return results;
	}
}

export function getClosestLayout(item, type) {
	let parent = item.parent;
	while (parent && parent.type != ItemType.Scene) {
		if (parent.layout) {
			if ( (!type) || (type && parent.layout.type === type))
				return parent.layout;
		}
		parent = parent.parent;
	}
	return undefined;
}

// export function isInGlyph(item) {
// 	let parent = item.parent;
// 	while (parent && parent.type != ItemType.Scene) {
// 		if (parent.type === ItemType.Glyph)
// 			return true;
// 		parent = parent.parent;
// 	}
// 	return false;
// }

export function getAllLayouts(items) { // get all layouts in a bottom-up manner
	let parents = getParents(items), allLayouts = [];
	while (parents && parents[0].type != ItemType.Scene) {
		for (let parent of parents) {
			if (parent.layout) {
				allLayouts.push(parent.layout);
			}
		}
		parents = getParents(parents);
	}
	return allLayouts;
}

export function getCellBoundsInLayout(item) {
	let itm = item, parent = item.parent;
	while (parent && parent.type != ItemType.Scene) {
		if (parent.layout){
			let idx = parent.children.findIndex(d => d == itm);
			return parent.layout.cellBounds[idx];
		}
		itm = itm.parent;
		parent = itm.parent;
	}
	return undefined;
}

export function getCellIndexInLayout(item) {
	let itm = item, parent = item.parent;
	while (parent && parent.type != ItemType.Scene) {
		if (parent.layout){
			return parent.children.findIndex(d => d == itm);
		}
		itm = itm.parent;
		parent = itm.parent;
	}
	return undefined;
}

export function getCellBoundsInGridLayout(item) {
	let itm = item, parent = item.parent;
	while (parent && parent.type != ItemType.Scene) {
		if (parent.layout && parent.layout.type == LayoutType.Grid){
			let idx = parent.children.findIndex(d => d == itm);
			return parent.layout.cellBounds[idx];
		}
		itm = itm.parent;
		parent = itm.parent;
	}
	return undefined;
}

export function getTopLevelLayout(item, type) {
	let parent = item.parent, layout = undefined;
	while (parent && parent.type !== ItemType.Scene) {
		if (parent.layout)
			if ( (!type) || (type && parent.layout.type === type))
				layout = parent.layout;
		parent = parent.parent;
	}
	return layout;
}

export function getEncodingKey(item) {
	if (item.classId) {
		return item.classId;
	} else if (item.type == "vertex" && item.dataScope) { //vertex created from densify
		if (item.parent.type === ItemType.Area) {
			let firstHalf = item.parent.vertices.indexOf(item) < item.parent.vertices.length/2;
			return item.parent.classId + "_v_" + (firstHalf ? 0 : item.parent.vertices.length-1) ;
		} 
		else
			return item.parent.classId + "_v";
	} else if (item.type == "vertex") { //vertex with index
		return item.parent.classId + "_v_" + item.parent.vertices.indexOf(item);
	} else if (item.type == "segment" && item.dataScope) { //segment created from densify
		return item.parent.classId + "_s";
	} else if (item.type == "segment") { //segment with index
		return item.parent.classId + "_s_" + item.parent.segments.indexOf(item);
	} else {
		return null;
	}
}

export function sameClass(item1, item2) {
	return getEncodingKey(item1).split("_")[0] === getEncodingKey(item2).split("_")[0];
}

export function getParents(items) {
	let result = [];
	for (let p of items) {
		if (p.parent && result.indexOf(p.parent) < 0)
			result.push(p.parent);
	}
	return result;
}

export function getAllChildren(cpnt) {
	let result = [];
	if (cpnt.children && cpnt.children.length > 0) {
		for (let c of cpnt.children) {
			result.push(c);
			result = result.concat(getAllChildren(c));
		}
	}
	return result;
}

export function getLeafMarks(cpnt) {
	let result = [];
	if (isMark(cpnt)) {
		result.push(cpnt);
	} else if (cpnt.children && cpnt.children.length > 0 && !isGuide(cpnt)) {
		for (let c of cpnt.children) {
			result = result.concat(getLeafMarks(c));
		}
	} 
	return result;
}

export function getLeafItems(cpnt) {
	let result = [];
	if (cpnt.children && cpnt.children.length > 0) {
		for (let c of cpnt.children) {
			result = result.concat(getLeafItems(c));
		}
	} else {
		result.push(cpnt);
	}
	return result;
}

export function isGuide(item) {
	return item.type === ItemType.Axis || item.type === ItemType.Legend || item.type === ItemType.Gridlines;
}

export function isMark(cmpnt) {
	return cmpnt instanceof Mark;
}

export function isPath(cmpnt) {
	return cmpnt instanceof Path;
}

export function isPartOfLegend(cmpnt) {
	let itm = cmpnt;
	while (itm.parent) {
		itm = itm.parent;
		if (itm.type == ItemType.Legend)
			return true;
	}
	return false;
}

export function itemIsRepeatable(itm) {
	// if (!itm.dataScope)
	// 	return true;
	// else if (itm)
	// 	return itm.dataScope.numTuples.length > 1;
	if ((isMark(itm) || itm.type == ItemType.Glyph) && !itm.dataScope)
		return true;
	else if (itm.type === ItemType.Collection)
		return itm.firstChild.dataScope.numTuples > 1;
	
	return false;
}

export const ItemCounter = {
	"area" : 0,
	"rect" : 0,
	"circle": 0,
	"pie": 0,
	"line": 0,
	"path" : 0,
	"ring" : 0,
	"arc": 0,
	"image": 0,
	"pointText": 0,
	"collection": 0,
	"group": 0,
	"scene": 0,
	"axis": 0,
	"glyph": 0,
	"legend": 0,
	"polygon": 0,
	"gridlines": 0,
	"LinearGradient": 0,
	"link": 0,
	"scale": 0,
	"datatable": 0
}

export function canAlign(items, direction, scene){
	if (direction == Alignment.Top || direction == Alignment.Bottom || direction == Alignment.Middle) {
		for (let item of items) {
			if (!canMoveVertically(item, scene))
				return false;
		}
		return true;
	}

	if (direction == Alignment.Left || direction == Alignment.Right || direction == Alignment.Center) {
		for (let item of items) {
			if (!canMoveHorizontally(item, scene))
				return false;
		}
		return true;
	}
}

function canMoveHorizontally(item, scene) {
	if (scene.getEncodingByItem(item, "x"))
		return false;
	if (item.parent && item.parent.layout) {
		let layout = item.parent.layout;
		if (layout.type == LayoutType.Grid && layout.numCols > 1) {
			return false;
		}
	}
	if (item.parent && item.parent.type != ItemType.Scene){
		return canMoveHorizontally(item.parent, scene);
	}
	return true;
}

function canMoveVertically(item, scene) {
	if (scene.getEncodingByItem(item, "y"))
		return false;
	if (item.parent && item.parent.layout) {
		let layout = item.parent.layout;
		if (layout.type == LayoutType.Grid && layout.numRows > 1) {
			return false;
		}
	}
	if (item.parent && item.parent.type != ItemType.Scene){
		return canMoveVertically(item.parent, scene);
	}
	return true;
}

export function getCommonAncestor(items) {
	let parents = items.map(d => d.parent);
	let uniqueParents = [...new Set(parents)];
	if (uniqueParents.length == 1)
		return uniqueParents[0];
	else
		return getCommonAncestor(parents);
}

export var CanvasProvider = {
	canvas : undefined,

	getCanvas: function() {
		if (!window)
            return null;
		if (this.canvas === undefined) {
			this.canvas = document.createElement('canvas');
		}
		return this.canvas;
	},

	getContext: function() {
        var canvas = this.getCanvas();
        return canvas ? canvas.getContext('2d') : null;
    },
}

export var SVGProvider = {
	svg: undefined,

	getSVG: function() {
		if (!window)
            return null;
		if (this.svg === undefined) {
			this.svg = document.createElement('svg');
		}
		return this.svg;
	}
}

// export function getTextWidth(text, font) {
// 	let context = CanvasProvider.getContext();
// 	context.font = font;
// 	let metrics = context.measureText(text);
// 	return metrics.width;
// }

export function getTextSize(text, font, fontSize) {
	let context = CanvasProvider.getContext();
	context.font = font;
	let metrics = context.measureText(text);
	if (metrics.fontBoundingBoxAscent)
		return {width: metrics.width, height: metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent};
	else if (metrics.actualBoundingBoxAscent)
		return {width: metrics.width, height: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent};
	else
		return {width: metrics.width, height: fontSize};
}

export function getAncestorsToAlign (items) {
	let parents = items.map(d => (d.parent && d.parent.type != ItemType.Scene) ? d.parent : d);
	let uniqueParents = [...new Set(parents)];
	if (uniqueParents.length == 1)
		return items;
	else
		return getAncestorsToAlign(parents);
}

export function getTopLevelGroup(item) {
	let parent = item.parent;
	if (parent.type == ItemType.Scene)
		return item;
	else
		return getTopLevelGroup(parent);
}

export function getTopLevelCollection(item) {
	let parent = item.parent;
	if (item.type == ItemType.Collection) {
		if (parent.type == ItemType.Collection) {
			return getTopLevelCollection(parent); 
		} else
			return item;
	} else if (parent.type != ItemType.Scene) {
		return getTopLevelCollection(parent); 
	} else {
		return undefined;
	}
}

export function polar2Cartesian(cx, cy, r, deg){
	let x = r * Math.cos(degree2radian(deg)),
		y = r * Math.sin(degree2radian(deg));
	return [x + cx, cy - y];
}

export function cartesian2Polar(x, y, cx, cy){
	let d = radian2degree(Math.atan2(cy - y, x - cx));
    d = Math.round( d * 10 + Number.EPSILON ) / 10
    if (d < 0) d += 360;
    let r = Math.sqrt(Math.pow(x-cx, 2) + Math.pow(y-cy, 2));
    r = Math.round( r * 10 + Number.EPSILON ) / 10
    return [d, r];
}

export function degree2radian(d){
	return d * Math.PI/180;
}

export function radian2degree(r){
	return r * 180 / Math.PI;
}

export function CheckAreaOrien(area){
	let VNum = area.vertices.length;
	for (let i = 0; i < area.vertices.length / 2; i++) {
		let Vid1 = i, Vid2 = VNum - i - 1;
		let peer1 = area.vertices[Vid1], peer2 = area.vertices[Vid2]
		if (peer1.x == peer2.x && peer1.y == peer2.y) {
			continue;
		} else {
			if (peer1.x == peer2.x) {
				return "horizontal";
			} else {
				return "vertical";
			}
		}
	}
}

export function getLayout(type, params) {
	let args = params ? params : {};
	switch (type.toLowerCase()) {
		case "grid":
			return new GridLayout(args);
		// case "circular":
		// 	return new CircularLayout(args);
		case "packing":
			return new PackingLayout(args);
		case "treemap":
			return new TreemapLayout(args);
		case "stack":
			return new StackLayout(args);
		case "tidytree":
			return new TidyTreeLayout(args);
		case "force":
			return new ForceLayout(args);
		case "sugiyama":
			return new SugiyamaLayout(args);
		case "strata":
			return new StrataLayout(args);
	}
}