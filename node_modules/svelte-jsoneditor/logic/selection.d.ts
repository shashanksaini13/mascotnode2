import type { JSONData, JSONPatchDocument, Selection } from '../types';
export declare const SELECTION_TYPE: {
    AFTER: string;
    INSIDE: string;
    KEY: string;
    VALUE: string;
    MULTI: string;
};
/**
 * Expand a selection start and end into an array containing all paths
 * between (and including) start and end
 *
 * @param {JSON} json
 * @param {JSON} state
 * @param {Path} anchorPath
 * @param {Path} focusPath
 * @return {Path[]} paths
 */
export declare function expandSelection(json: any, state: any, anchorPath: any, focusPath: any): any[];
/**
 * @param {Selection} selection
 * @return {Path} Returns parent path
 */
export declare function getParentPath(selection: any): any;
/**
 * @param {Selection} selection
 * @returns {Path}
 */
export declare function getStartPath(selection: any): any;
/**
 * @param {Selection} selection
 * @returns {Path}
 */
export declare function getEndPath(selection: any): any;
/**
 * @param {Selection} selection
 * @param {Path} path
 * @return boolean
 */
export declare function isSelectionInsidePath(selection: any, path: any): boolean;
/**
 * @param {Selection} selection
 * @param {Path} path
 * @param {string} anchorType
 * @return boolean
 */
export declare function isPathInsideSelection(selection: any, path: any, anchorType: any): boolean;
/**
 * @param {JSON} json
 * @param {JSON} state
 * @param {Selection} selection
 * @param {boolean} [keepAnchorPath=false]
 * @param {boolean} [useFocusPath=false]
 * @returns {Selection | null}
 */
export declare function getSelectionUp(json: any, state: any, selection: any, keepAnchorPath?: boolean, useFocusPath?: boolean): import("../types").MultiSelection | import("../types").KeySelection | import("../types").ValueSelection | {
    type: string;
    anchorPath: any;
    focusPath: any;
};
/**
 * @param {JSON} json
 * @param {JSON} state
 * @param {Selection} selection
 * @param {boolean} [keepAnchorPath=false]
 * @param {boolean} [useFocusPath=false]
 * @returns {Selection | null}
 */
export declare function getSelectionDown(json: any, state: any, selection: any, keepAnchorPath?: boolean, useFocusPath?: boolean): Selection | null;
/**
 * Get the next selection for a value inside the current object/array
 * If there is no next value, select AFTER.
 * Only applicable for SELECTION_TYPE.VALUE
 * @param {JSON} json
 * @param {JSON} state
 * @param {Selection} selection
 * @returns {Selection | null}
 */
export declare function getSelectionNextInside(json: any, state: any, selection: any): Selection;
/**
 * Find the caret position and its siblings for a given selection
 * @param {JSON} json
 * @param {JSON} state
 * @param {Selection} selection
 * @param {boolean} includeInside
 * @returns {{next: (CaretPosition|null), caret: (CaretPosition|null), previous: (CaretPosition|null)}}
 */
export declare function findCaretAndSiblings(json: any, state: any, selection: any, includeInside: any): {
    caret: any;
    previous: any;
    next: any;
};
/**
 * @param {JSON} json
 * @param {JSON} state
 * @param {Selection} selection
 * @param {boolean} [keepAnchorPath=false]
 * @param {boolean} [includeInside=true]
 * @returns {Selection | null}
 */
export declare function getSelectionLeft(json: any, state: any, selection: any, keepAnchorPath?: boolean, includeInside?: boolean): Selection;
/**
 * @param {JSON} json
 * @param {JSON} state
 * @param {Selection} selection
 * @param {boolean} [keepAnchorPath=false]
 * @param {boolean} [includeInside=true]
 * @returns {Selection | null}
 */
export declare function getSelectionRight(json: any, state: any, selection: any, keepAnchorPath?: boolean, includeInside?: boolean): Selection;
/**
 * Get a proper initial selection based on what is visible
 * @param {JSON} json
 * @param {JSON} state
 * @returns {Selection}
 */
export declare function getInitialSelection(json: any, state: any): {
    type: string;
    anchorPath: any;
    focusPath: any;
};
export declare function createSelectionFromOperations(json: JSONData, state: JSONData, operations: JSONPatchDocument): Selection | null;
/**
 * @param {Path[]} paths
 * @returns {Object}
 */
export declare function createPathsMap(paths: any): {};
/**
 * Find the common path of two paths.
 * For example findCommonRoot(['arr', '1', 'name'], ['arr', '1', 'address', 'contact']) returns ['arr', '1']
 * @param {Path} path1
 * @param {Path} path2
 * @return {Path}
 */
export declare function findSharedPath(path1: any, path2: any): any;
/**
 * @param {Selection} [selection]
 * @returns {boolean}
 */
export declare function singleItemSelected(selection: any): boolean;
/**
 * @param {JSON} json
 * @param {Selection} selection
 * @return {Path}
 */
export declare function findRootPath(json: any, selection: any): any;
/**
 * @param {Path} path
 * @param {Path} parentPath
 * @return boolean
 */
export declare function pathStartsWith(path: any, parentPath: any): boolean;
/**
 * @param {Selection} selection
 * @return {Selection}
 */
export declare function removeEditModeFromSelection(selection: any): any;
/**
 * @param {JSON} json
 * @param {JSON} state
 * @param {SelectionSchema} selectionSchema
 * @return {Selection}
 */
export declare function createSelection(json: any, state: any, selectionSchema: any): Selection;
/**
 * Turn selected contents into plain text partial JSON, usable for copying to
 * clipboard for example.
 * @param {JSON} json
 * @param {Selection} selection
 * @param {number} [indentation=2]
 * @returns {string | null}
 */
export declare function selectionToPartialJson(json: any, selection: any, indentation?: number): any;
/**
 * @param {JSON} referenceJson
 * @param {Selection} selection
 * @returns {RecursiveSelection | null}
 */
export declare function createRecursiveSelection(referenceJson: any, selection: any): {};
/**
 * Create a selection which selects the whole document
 * @returns {Selection}
 */
export declare function selectAll(): {
    type: string;
    anchorPath: any[];
    focusPath: any[];
};
/**
 * Test whether the current selection can be converted.
 * That is the case when the selection is a key/value, or a multi selection with only one path
 * @param {Selection} selection
 * @return {boolean}
 */
export declare function canConvert(selection: any): boolean;
/**
 * @param {Path} path
 * @param {string} key
 * @param {RecursiveSelection} resolvedSelection
 * @returns {boolean}
 */
export declare function keyIsSelected(path: any, key: any, resolvedSelection: any): boolean;
