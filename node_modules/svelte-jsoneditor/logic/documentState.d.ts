import type { JSONData, JSONPatchDocument, Path } from '../types';
/**
 * Sync a state object with the json it belongs to: update keys, limit, and expanded state
 *
 * When forceRefresh=true, force refreshing the expanded state
 */
export declare function syncState(json: JSONData, state: JSONData, path: Path, expand: (path: Path) => boolean, forceRefresh?: boolean): JSONData;
export declare function createState(json: any): {};
/**
 * Expand a node
 * @param {JSON} json
 * @param {JSON} state
 * @param {Path} path
 * @return {JSON} returns the updated state
 */
export declare function expandSinglePath(json: any, state: any, path: any): any;
/**
 * Invoke a callback function for every visible item in the array
 * @param {JSON} json
 * @param {JSON} state
 * @param {function (index: number)} callback
 */
export declare function forEachVisibleIndex(json: any, state: any, callback: any): void;
export declare function forEachKey(state: any, callback: any): void;
/**
 * Expand all nodes on given path
 * @param {JSON} json
 * @param {JSON} state
 * @param {Path} path
 * @return {JSON} returns the updated state
 */
export declare function expandPath(json: any, state: any, path: any): any;
/**
 * Expand a node, end expand it's childs according to the provided callback
 * @param {JSON} json
 * @param {JSON} state
 * @param {Path} path
 * @param {(path: Path) => boolean} expandedCallback
 * @returns {JSON} Returns the updated state
 */
export declare function expandWithCallback(json: any, state: any, path: any, expandedCallback: any): import("immutable-json-patch").JSONData;
/**
 * @param {JSON} json
 * @param {JSON} state
 * @param {Path} path
 * @returns {JSON} Returns the updated state
 */
export declare function collapse(json: any, state: any, path: any): import("immutable-json-patch").JSONData;
/**
 * If needed, enlarge the expanded sections such that the search result becomes visible in the array
 * @param {JSON} state
 * @param {Path} path
 * @param {number} index
 * @returns {JSON}
 */
export declare function ensureItemIsVisible(state: any, path: any, index: any): any;
export declare function expandRecursively(json: any, state: any, path: any): import("immutable-json-patch").JSONData;
/**
 * Collapse the node at given path
 * @param {JSON} json
 * @param {JSON} state
 * @param {Path} path
 * @returns {JSON} returns the updated state
 */
export declare function collapseSinglePath(json: any, state: any, path: any): any;
/**
 * Expand a section of items in an array
 * @param {JSON} json
 * @param {JSON} state
 * @param {Path} path
 * @param {Section} section
 * @return {JSON} returns the updated state
 */
export declare function expandSection(json: any, state: any, path: any, section: any): JSONData;
export declare function syncKeys(object: Record<string, unknown>, prevKeys?: string[]): string[];
/**
 * Apply patch operations to both json and state
 */
export declare function documentStatePatch(json: JSONData, state: JSONData, operations: JSONPatchDocument): {
    json: JSONData;
    state: JSONData;
};
/**
 * Initialize the state needed to perform the JSON patch operations.
 * For example to a change in a nested object which is not expanded and
 * hence has no state initialize, we need to create this nested state
 * @param {JSON} json
 * @param {JSON} state
 * @param {JSONPatchDocument} operations
 */
export declare function initializeState(json: any, state: any, operations: any): any;
/**
 * Shift visible sections in an Array with a specified offset
 * @param {JSON} state
 * @param {Path} path
 * @param {number} offset
 * @returns {JSON} Returns the updated state
 */
export declare function shiftVisibleSections(state: any, path: any, offset: any): any;
export declare function getKeys(state: JSONData, path: Path): string[];
export declare function isExpanded(state: JSONData, path: Path): boolean;
/**
 * Remove a key from the keys of an object at given path.
 * Returns the updated state
 */
export declare function removeFromKeys(state: JSONData, path: Path, key: string): JSONData;
export declare function replaceInKeys(state: JSONData, path: Path, oldKey: string, newKey: string): import("immutable-json-patch").JSONData;
export declare function appendToKeys(state: JSONData, path: Path, key: string): import("immutable-json-patch").JSONData;
export declare function getNextKeys(keys: any, key: any, includeKey?: boolean): any;
/**
 * Get all paths which are visible and rendered
 * @param {JSON} json
 * @param {JSON} state
 * @returns {Path[]}
 */
export declare function getVisiblePaths(json: any, state: any): any[];
export declare const CARET_POSITION: {
    INSIDE: string;
    AFTER: string;
    KEY: string;
    VALUE: string;
};
/**
 * Get all caret position which are visible and rendered:
 * before a node, at a key, at a value, appending an object/arrayc
 * @param {JSON} json
 * @param {JSON} state
 * @param {boolean} [includeInside=true]
 * @returns {CaretPosition[]}
 */
export declare function getVisibleCaretPositions(json: any, state: any, includeInside?: boolean): any[];
/**
 * Find the previous visible path.
 * This can be the last child of the previous object or array, or the parent of a first entry.
 * @param {JSON} json
 * @param {JSON} state
 * @param {Path} path
 * @return {Path | null}
 */
export declare function getPreviousVisiblePath(json: any, state: any, path: any): any;
/**
 * Find the next visible path.
 * This can be the next parent entry.
 * @param {JSON} json
 * @param {JSON} state
 * @param {Path} path
 * @return {Path | null} path
 */
export declare function getNextVisiblePath(json: any, state: any, path: any): any;
