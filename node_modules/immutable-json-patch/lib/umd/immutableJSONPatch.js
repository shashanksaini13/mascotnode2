(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.immutableJSONPatch = {}));
}(this, (function (exports) { 'use strict';

  function _typeof$1(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$1 = function _typeof(obj) { return typeof obj; }; } else { _typeof$1 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$1(obj); }

  /**
   * Test deep equality of two JSON values, objects, or arrays
   * @param {JSONData} a
   * @param {JSONData} b
   * @returns {boolean}
   */
  // TODO: write unit tests
  function isEqual(a, b) {
    // FIXME: this function will return false for two objects with the same keys
    //  but different order of keys
    return JSON.stringify(a) === JSON.stringify(b);
  }
  /**
   * Test whether two values are strictly equal
   * @param {*} a
   * @param {*} b
   * @returns {boolean}
   */

  function strictEqual(a, b) {
    return a === b;
  }
  /**
   * Get all but the last items from an array
   * @param {Array} array
   * @return {Array}
   */
  // TODO: write unit tests

  function initial(array) {
    return array.slice(0, array.length - 1);
  }
  /**
   * Get the last item from an array
   * @param {Array} array
   * @returns {*}
   */
  // TODO: write unit tests

  function last(array) {
    return array[array.length - 1];
  }
  /**
   * Test whether array1 starts with array2
   * @param {Array} array1
   * @param {Array} array2
   * @param {function} [isEqual=strictEqual] Optional function to check equality
   */

  function startsWith(array1, array2) {
    var isEqual = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : strictEqual;

    if (array1.length < array2.length) {
      return false;
    }

    for (var i = 0; i < array2.length; i++) {
      if (!isEqual(array1[i], array2[i])) {
        return false;
      }
    }

    return true;
  }
  /**
   * Test whether a value is an Object or an Array (and not a primitive JSON value)
   * @param {*} value
   * @return {boolean}
   */
  // TODO: write unit tests

  function isObjectOrArray(value) {
    return _typeof$1(value) === 'object' && value !== null;
  }

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
  /**
   * Shallow clone of an Object, Array, or value
   * Symbols are cloned too.
   * @param {*} value
   * @return {*}
   */

  function shallowClone(value) {
    if (Array.isArray(value)) {
      // copy array items
      var copy = value.slice(); // copy all symbols

      Object.getOwnPropertySymbols(value).forEach(function (symbol) {
        copy[symbol] = value[symbol];
      });
      return copy;
    } else if (_typeof(value) === 'object') {
      // copy object properties
      var _copy = _objectSpread({}, value); // copy all symbols


      Object.getOwnPropertySymbols(value).forEach(function (symbol) {
        _copy[symbol] = value[symbol];
      });
      return _copy;
    } else {
      return value;
    }
  }
  /**
   * Update a value in an object in an immutable way.
   * If the value is unchanged, the original object will be returned
   * @param {Object | Array} object
   * @param {string | index} key
   * @param {*} value
   * @returns {Object | Array}
   */

  function applyProp(object, key, value) {
    if (object[key] === value) {
      // return original object unchanged when the new value is identical to the old one
      return object;
    } else {
      var updatedObject = shallowClone(object);
      updatedObject[key] = value;
      return updatedObject;
    }
  }
  /**
   * helper function to get a nested property in an object or array
   *
   * @param {Object | Array} object
   * @param {JSONPath} path
   * @return {* | undefined} Returns the field when found, or undefined when the
   *                         path doesn't exist
   */

  function getIn(object, path) {
    var value = object;
    var i = 0;

    while (i < path.length) {
      if (isObjectOrArray(value)) {
        value = value[path[i]];
      } else {
        value = undefined;
      }

      i++;
    }

    return value;
  }
  /**
   * helper function to replace a nested property in an object with a new value
   * without mutating the object itself.
   *
   * @param {Object | Array} object
   * @param {JSONPath} path
   * @param {*} value
   * @param {boolean} [createPath=false]
   *                    If true, `path` will be created when (partly) missing in
   *                    the object. For correctly creating nested Arrays or
   *                    Objects, the function relies on `path` containing a number
   *                    in case of array indexes.
   *                    If false (default), an error will be thrown when the
   *                    path doesn't exist.
   * @return {Object | Array} Returns a new, updated object or array
   */

  function setIn(object, path, value) {
    var createPath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    if (path.length === 0) {
      return value;
    }

    var key = path[0];
    var updatedValue = setIn(object ? object[key] : undefined, path.slice(1), value, createPath);

    if (!isObjectOrArray(object)) {
      if (createPath) {
        var newObject = typeof key === 'number' ? [] : {};
        newObject[key] = updatedValue;
        return newObject;
      } else {
        throw new Error('Path does not exist');
      }
    }

    return applyProp(object, key, updatedValue);
  }
  /**
   * helper function to replace a nested property in an object with a new value
   * without mutating the object itself.
   *
   * @param {Object | Array} object
   * @param {JSONPath} path
   * @param {function} callback
   * @return {Object | Array} Returns a new, updated object or array
   */

  function updateIn(object, path, callback) {
    if (path.length === 0) {
      return callback(object);
    }

    if (!isObjectOrArray(object)) {
      throw new Error('Path doesn\'t exist');
    }

    var key = path[0];
    var updatedValue = updateIn(object[key], path.slice(1), callback);
    return applyProp(object, key, updatedValue);
  }
  /**
   * helper function to delete a nested property in an object
   * without mutating the object itself.
   *
   * @param {Object | Array} object
   * @param {JSONPath} path
   * @return {Object | Array} Returns a new, updated object or array
   */

  function deleteIn(object, path) {
    if (path.length === 0) {
      return object;
    }

    if (!isObjectOrArray(object)) {
      throw new Error('Path does not exist');
    }

    if (path.length === 1) {
      var _key = path[0];

      if (!(_key in object)) {
        // key doesn't exist. return object unchanged
        return object;
      } else {
        var updatedObject = shallowClone(object);

        if (Array.isArray(updatedObject)) {
          updatedObject.splice(_key, 1);
        } else {
          delete updatedObject[_key];
        }

        return updatedObject;
      }
    }

    var key = path[0];
    var updatedValue = deleteIn(object[key], path.slice(1));
    return applyProp(object, key, updatedValue);
  }
  /**
   * Insert a new item in an array at a specific index.
   * Example usage:
   *
   *     insertAt({arr: [1,2,3]}, ['arr', '2'], 'inserted')  // [1,2,'inserted',3]
   *
   * @param {Object | Array} object
   * @param {JSONPath} path
   * @param {*} value
   * @return {Array}
   */

  function insertAt(object, path, value) {
    var parentPath = path.slice(0, path.length - 1);
    var index = path[path.length - 1];
    return updateIn(object, parentPath, function (items) {
      if (!Array.isArray(items)) {
        throw new TypeError('Array expected at path ' + JSON.stringify(parentPath));
      }

      var updatedItems = shallowClone(items);
      updatedItems.splice(index, 0, value);
      return updatedItems;
    });
  }
  /**
   * Test whether a path exists in a JSON object
   * @param {JSONData} json
   * @param {JSONPath} path
   * @return {boolean} Returns true if the path exists, else returns false
   * @private
   */

  function existsIn(json, path) {
    if (json === undefined) {
      return false;
    }

    if (path.length === 0) {
      return true;
    }

    return existsIn(json[path[0]], path.slice(1));
  }

  /**
   * Parse a JSON Pointer
   * @param {string} pointer
   * @return {JSONPath}
   */
  function parseJSONPointer(pointer) {
    var path = pointer.split('/');
    path.shift(); // remove the first empty entry

    return path.map(function (p) {
      return p.replace(/~1/g, '/').replace(/~0/g, '~');
    });
  }
  /**
   * Compile a JSON Pointer
   * @param {JSONPath} path
   * @return {string}
   */

  function compileJSONPointer(path) {
    return path.map(function (p) {
      return '/' + String(p).replace(/~/g, '~0').replace(/\//g, '~1');
    }).join('');
  }

  /**
   * Apply a patch to a JSON object
   * The original JSON object will not be changed,
   * instead, the patch is applied in an immutable way
   * @param {JSONData} json
   * @param {JSONPatchDocument} operations    Array with JSON patch actions
   * @param {JSONPatchOptions} [options]
   * @return {JSONData} Returns the updated json
   */

  function immutableJSONPatch(json, operations, options) {
    var updatedJson = json;

    for (var i = 0; i < operations.length; i++) {
      validateJSONPatchOperation(operations[i]);
      var operation = preprocessJSONPatchOperation(updatedJson, operations[i]); // TODO: test before

      if (options && options.before) {
        var result = options.before(updatedJson, operation);

        if (result !== undefined) {
          if (result.json !== undefined) {
            updatedJson = result.json;
          }

          if (result.operation !== undefined) {
            operation = result.operation;
          }
        }
      }

      var previousJson = updatedJson;
      var patchOp = PATCH_OPS[operation.op];

      if (patchOp) {
        updatedJson = patchOp(updatedJson, operation);
      } else if (operation.op === 'test') {
        test(updatedJson, operation);
      } else {
        throw new Error('Unknown JSONPatch operation ' + JSON.stringify(operation.op));
      } // TODO: test after


      if (options && options.after) {
        var _result = options.after(updatedJson, operation, previousJson);

        if (_result !== undefined) {
          updatedJson = _result;
        }
      }
    }

    return updatedJson;
  }
  var PATCH_OPS = {
    add: add,
    remove: remove,
    replace: replace,
    copy: copy,
    move: move
  };
  /**
   * Replace an existing item
   * @param {JSONData} json
   * @param {{ path: JSONPath, value: JSONData }} operation
   * @return {JSONData}
   */

  function replace(json, _ref) {
    var path = _ref.path,
        value = _ref.value;
    return setIn(json, path, value);
  }
  /**
   * Remove an item or property
   * @param {JSONData} json
   * @param {{ path: JSONPath }} operation
   * @return {JSONData}
   */

  function remove(json, _ref2) {
    var path = _ref2.path;
    return deleteIn(json, path);
  }
  /**
   * @param {JSONData} json
   * @param {{ path: JSONPath, value: JSONData }} operation
   * @return {JSONData}
   */

  function add(json, _ref3) {
    var path = _ref3.path,
        value = _ref3.value;

    if (isArrayItem(json, path)) {
      return insertAt(json, path, value);
    } else {
      return setIn(json, path, value);
    }
  }
  /**
   * Copy a value
   * @param {JSONData} json
   * @param {{ path: JSONPath, from: JSONPath }} operation
   * @return {JSONData}
   */

  function copy(json, _ref4) {
    var path = _ref4.path,
        from = _ref4.from;
    var value = getIn(json, from);

    if (isArrayItem(json, path)) {
      return insertAt(json, path, value);
    } else {
      var _value = getIn(json, from);

      return setIn(json, path, _value);
    }
  }
  /**
   * Move a value
   * @param {JSONData} json
   * @param {{ path: JSONPath, from: JSONPath }} operation
   * @return {JSONData}
   */

  function move(json, _ref5) {
    var path = _ref5.path,
        from = _ref5.from;
    var value = getIn(json, from);
    var removedJson = deleteIn(json, from);
    return isArrayItem(removedJson, path) ? insertAt(removedJson, path, value) : setIn(removedJson, path, value);
  }
  /**
   * Test whether the data contains the provided value at the specified path.
   * Throws an error when the test fails
   * @param {JSONData} json
   * @param {{ path: JSONPath, value: JSONData }} operation
   */

  function test(json, _ref6) {
    var path = _ref6.path,
        value = _ref6.value;

    if (value === undefined) {
      throw new Error("Test failed: no value provided (path: \"".concat(compileJSONPointer(path), "\")"));
    }

    if (!existsIn(json, path)) {
      throw new Error("Test failed: path not found (path: \"".concat(compileJSONPointer(path), "\")"));
    }

    var actualValue = getIn(json, path);

    if (!isEqual(actualValue, value)) {
      throw new Error("Test failed, value differs (path: \"".concat(compileJSONPointer(path), "\")"));
    }
  }
  /**
   * @param {JSONData} json
   * @param {JSONPath} path
   * @returns {boolean}
   */

  function isArrayItem(json, path) {
    if (path.length === 0) {
      return false;
    }

    var parent = getIn(json, initial(path));
    return Array.isArray(parent);
  }
  /**
   * Resolve the path index of an array, resolves indexes '-'
   * @param {JSONData} json
   * @param {JSONPath} path
   * @returns {JSONPath} Returns the resolved path
   */

  function resolvePathIndex(json, path) {
    if (last(path) !== '-') {
      return path;
    }

    var parentPath = initial(path);
    var parent = getIn(json, parentPath);
    return parentPath.concat(parent.length);
  }
  /**
   * Validate a JSONPatch operation.
   * Throws an error when there is an issue
   * @param {JSONPatchOperation} operation
   */

  function validateJSONPatchOperation(operation) {
    // TODO: write unit tests
    var ops = ['add', 'remove', 'replace', 'copy', 'move', 'test'];

    if (!ops.includes(operation.op)) {
      throw new Error('Unknown JSONPatch op ' + JSON.stringify(operation.op));
    }

    if (typeof operation.path !== 'string') {
      throw new Error('Required property "path" missing or not a string in operation ' + JSON.stringify(operation));
    }

    if (operation.op === 'copy' || operation.op === 'move') {
      if (typeof operation.from !== 'string') {
        throw new Error('Required property "from" missing or not a string in operation ' + JSON.stringify(operation));
      }
    }
  }
  /**
   * @param {JSONData} json
   * @param {JSONPatchOperation} operation
   * @return {PreprocessedJSONPatchOperation}
   */
  // TODO: write unit tests

  function preprocessJSONPatchOperation(json, operation) {
    return {
      op: operation.op,
      path: resolvePathIndex(json, parseJSONPointer(operation.path)),
      from: operation.from !== undefined ? parseJSONPointer(operation.from) : null,
      value: operation.value
    };
  }

  /**
   * Create the inverse of a set of json patch operations
   * @param {JSONData} json
   * @param {JSONPatchDocument} operations    Array with JSON patch actions
   * @return {JSONPatchDocument} Returns the operations to revert the changes
   */

  function revertJSONPatch(json, operations) {
    var revertOperations = [];
    immutableJSONPatch(json, operations, {
      before: function before(json, operation) {
        var revertOp = REVERT_OPS[operation.op];

        if (revertOp) {
          revertOperations = revertOp(json, operation).concat(revertOperations);
        }
      }
    });
    return revertOperations;
  }
  var REVERT_OPS = {
    add: revertAdd,
    remove: revertRemove,
    replace: revertReplace,
    copy: revertCopy,
    move: revertMove
  };
  /**
   * @param {JSONData} json
   * @param {{ path: JSONPath }} operation
   * @return {JSONPatchDocument}
   */

  function revertReplace(json, _ref) {
    var path = _ref.path;
    return [{
      op: 'replace',
      path: compileJSONPointer(path),
      value: getIn(json, path)
    }];
  }
  /**
   * @param {JSONData} json
   * @param {{ path: JSONPath }} operation
   * @return {JSONPatchDocument}
   */


  function revertRemove(json, _ref2) {
    var path = _ref2.path;
    return [{
      op: 'add',
      path: compileJSONPointer(path),
      value: getIn(json, path)
    }];
  }
  /**
   * @param {JSONData} json
   * @param {{ path: JSONPath, value: JSONData }} operation
   * @return {JSONPatchDocument}
   */


  function revertAdd(json, _ref3) {
    var path = _ref3.path,
        value = _ref3.value;

    if (isArrayItem(json, path) || !existsIn(json, path)) {
      return [{
        op: 'remove',
        path: compileJSONPointer(path)
      }];
    } else {
      return revertReplace(json, {
        path: path,
        value: value
      });
    }
  }
  /**
   * @param {JSONData} json
   * @param {{ path: JSONPath, value: JSONData }} operation
   * @return {JSONPatchDocument}
   */


  function revertCopy(json, _ref4) {
    var path = _ref4.path,
        value = _ref4.value;
    return revertAdd(json, {
      path: path,
      value: value
    });
  }
  /**
   * @param {JSONData} json
   * @param {{ path: JSONPath, from: JSONPath }} operation
   * @return {JSONPatchDocument}
   */


  function revertMove(json, _ref5) {
    var path = _ref5.path,
        from = _ref5.from;

    if (path.length < from.length && startsWith(from, path)) {
      // replacing the parent with the child
      return [{
        op: 'replace',
        path: compileJSONPointer(path),
        value: json
      }];
    }

    var revert = [{
      op: 'move',
      from: compileJSONPointer(path),
      path: compileJSONPointer(from)
    }];

    if (!isArrayItem(json, path) && existsIn(json, path)) {
      // the move replaces an existing value in an object
      revert = revert.concat(revertRemove(json, {
        path: path
      }));
    }

    return revert;
  }

  exports.compileJSONPointer = compileJSONPointer;
  exports.deleteIn = deleteIn;
  exports.existsIn = existsIn;
  exports.getIn = getIn;
  exports.immutableJSONPatch = immutableJSONPatch;
  exports.insertAt = insertAt;
  exports.parseJSONPointer = parseJSONPointer;
  exports.revertJSONPatch = revertJSONPatch;
  exports.setIn = setIn;
  exports.updateIn = updateIn;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=immutableJSONPatch.js.map
