"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.immutableJSONPatch = immutableJSONPatch;
exports.replace = replace;
exports.remove = remove;
exports.add = add;
exports.copy = copy;
exports.move = move;
exports.test = test;
exports.isArrayItem = isArrayItem;
exports.resolvePathIndex = resolvePathIndex;
exports.validateJSONPatchOperation = validateJSONPatchOperation;
exports.preprocessJSONPatchOperation = preprocessJSONPatchOperation;

var _immutabilityHelpers = require("./immutabilityHelpers.js");

var _jsonPointer = require("./jsonPointer.js");

var _utils = require("./utils.js");

/**
 * Apply a patch to a JSON object
 * The original JSON object will not be changed,
 * instead, the patch is applied in an immutable way
 * @param {JSONData} json
 * @param {JSONPatchDocument} operations    Array with JSON patch actions
 * @param {JSONPatchOptions} [options]
 * @return {JSONData} Returns the updated json
 */
function immutableJSONPatch(json, operations, options) {
  var updatedJson = json;

  for (var i = 0; i < operations.length; i++) {
    validateJSONPatchOperation(operations[i]);
    var operation = preprocessJSONPatchOperation(updatedJson, operations[i]); // TODO: test before

    if (options && options.before) {
      var result = options.before(updatedJson, operation);

      if (result !== undefined) {
        if (result.json !== undefined) {
          updatedJson = result.json;
        }

        if (result.operation !== undefined) {
          operation = result.operation;
        }
      }
    }

    var previousJson = updatedJson;
    var patchOp = PATCH_OPS[operation.op];

    if (patchOp) {
      updatedJson = patchOp(updatedJson, operation);
    } else if (operation.op === 'test') {
      test(updatedJson, operation);
    } else {
      throw new Error('Unknown JSONPatch operation ' + JSON.stringify(operation.op));
    } // TODO: test after


    if (options && options.after) {
      var _result = options.after(updatedJson, operation, previousJson);

      if (_result !== undefined) {
        updatedJson = _result;
      }
    }
  }

  return updatedJson;
}

var PATCH_OPS = {
  add: add,
  remove: remove,
  replace: replace,
  copy: copy,
  move: move
};
/**
 * Replace an existing item
 * @param {JSONData} json
 * @param {{ path: JSONPath, value: JSONData }} operation
 * @return {JSONData}
 */

function replace(json, _ref) {
  var path = _ref.path,
      value = _ref.value;
  return (0, _immutabilityHelpers.setIn)(json, path, value);
}
/**
 * Remove an item or property
 * @param {JSONData} json
 * @param {{ path: JSONPath }} operation
 * @return {JSONData}
 */


function remove(json, _ref2) {
  var path = _ref2.path;
  return (0, _immutabilityHelpers.deleteIn)(json, path);
}
/**
 * @param {JSONData} json
 * @param {{ path: JSONPath, value: JSONData }} operation
 * @return {JSONData}
 */


function add(json, _ref3) {
  var path = _ref3.path,
      value = _ref3.value;

  if (isArrayItem(json, path)) {
    return (0, _immutabilityHelpers.insertAt)(json, path, value);
  } else {
    return (0, _immutabilityHelpers.setIn)(json, path, value);
  }
}
/**
 * Copy a value
 * @param {JSONData} json
 * @param {{ path: JSONPath, from: JSONPath }} operation
 * @return {JSONData}
 */


function copy(json, _ref4) {
  var path = _ref4.path,
      from = _ref4.from;
  var value = (0, _immutabilityHelpers.getIn)(json, from);

  if (isArrayItem(json, path)) {
    return (0, _immutabilityHelpers.insertAt)(json, path, value);
  } else {
    var _value = (0, _immutabilityHelpers.getIn)(json, from);

    return (0, _immutabilityHelpers.setIn)(json, path, _value);
  }
}
/**
 * Move a value
 * @param {JSONData} json
 * @param {{ path: JSONPath, from: JSONPath }} operation
 * @return {JSONData}
 */


function move(json, _ref5) {
  var path = _ref5.path,
      from = _ref5.from;
  var value = (0, _immutabilityHelpers.getIn)(json, from);
  var removedJson = (0, _immutabilityHelpers.deleteIn)(json, from);
  return isArrayItem(removedJson, path) ? (0, _immutabilityHelpers.insertAt)(removedJson, path, value) : (0, _immutabilityHelpers.setIn)(removedJson, path, value);
}
/**
 * Test whether the data contains the provided value at the specified path.
 * Throws an error when the test fails
 * @param {JSONData} json
 * @param {{ path: JSONPath, value: JSONData }} operation
 */


function test(json, _ref6) {
  var path = _ref6.path,
      value = _ref6.value;

  if (value === undefined) {
    throw new Error("Test failed: no value provided (path: \"".concat((0, _jsonPointer.compileJSONPointer)(path), "\")"));
  }

  if (!(0, _immutabilityHelpers.existsIn)(json, path)) {
    throw new Error("Test failed: path not found (path: \"".concat((0, _jsonPointer.compileJSONPointer)(path), "\")"));
  }

  var actualValue = (0, _immutabilityHelpers.getIn)(json, path);

  if (!(0, _utils.isEqual)(actualValue, value)) {
    throw new Error("Test failed, value differs (path: \"".concat((0, _jsonPointer.compileJSONPointer)(path), "\")"));
  }
}
/**
 * @param {JSONData} json
 * @param {JSONPath} path
 * @returns {boolean}
 */


function isArrayItem(json, path) {
  if (path.length === 0) {
    return false;
  }

  var parent = (0, _immutabilityHelpers.getIn)(json, (0, _utils.initial)(path));
  return Array.isArray(parent);
}
/**
 * Resolve the path index of an array, resolves indexes '-'
 * @param {JSONData} json
 * @param {JSONPath} path
 * @returns {JSONPath} Returns the resolved path
 */


function resolvePathIndex(json, path) {
  if ((0, _utils.last)(path) !== '-') {
    return path;
  }

  var parentPath = (0, _utils.initial)(path);
  var parent = (0, _immutabilityHelpers.getIn)(json, parentPath);
  return parentPath.concat(parent.length);
}
/**
 * Validate a JSONPatch operation.
 * Throws an error when there is an issue
 * @param {JSONPatchOperation} operation
 */


function validateJSONPatchOperation(operation) {
  // TODO: write unit tests
  var ops = ['add', 'remove', 'replace', 'copy', 'move', 'test'];

  if (!ops.includes(operation.op)) {
    throw new Error('Unknown JSONPatch op ' + JSON.stringify(operation.op));
  }

  if (typeof operation.path !== 'string') {
    throw new Error('Required property "path" missing or not a string in operation ' + JSON.stringify(operation));
  }

  if (operation.op === 'copy' || operation.op === 'move') {
    if (typeof operation.from !== 'string') {
      throw new Error('Required property "from" missing or not a string in operation ' + JSON.stringify(operation));
    }
  }
}
/**
 * @param {JSONData} json
 * @param {JSONPatchOperation} operation
 * @return {PreprocessedJSONPatchOperation}
 */
// TODO: write unit tests


function preprocessJSONPatchOperation(json, operation) {
  return {
    op: operation.op,
    path: resolvePathIndex(json, (0, _jsonPointer.parseJSONPointer)(operation.path)),
    from: operation.from !== undefined ? (0, _jsonPointer.parseJSONPointer)(operation.from) : null,
    value: operation.value
  };
}
//# sourceMappingURL=immutableJSONPatch.js.map